# B4860-IR

## libuv

> 官网：
>
> [libuv中文文档](https://libuv-docs-chinese.readthedocs.io/zh/latest/)
>
> [libuv 1.34.3 文档](http://docs.libuv.org/en/v1.x/index.html)
>
> [libuv源码解析之数据结构全景图](https://cloud.tencent.com/developer/article/1574086)
>
> [libuv之线程池以及线程间通信源码解析](https://cloud.tencent.com/developer/article/1403972)
>
> [libuv的定时器原理源码解析](https://cloud.tencent.com/developer/article/1403969)
>
> [libuv之async.c源码解析](https://cloud.tencent.com/developer/article/1403971)
>
> [对libuv的C++封装](https://segmentfault.com/a/1190000018578830)

> [libuv 源码分析（一）全局概览（Overview）](https://blog.butonly.com/posts/node.js/libuv/1-libuv-overview/)
>
> [基于libuv的TCP设计（二）](https://www.cnblogs.com/wqvbjhc/p/3758141.html) **
>
> [libuv 高并发异步使用](https://blog.csdn.net/xcw_1987/article/details/79977726)
>
> [简单易懂的高性能tcp服务器设计](https://zhuanlan.zhihu.com/p/35358510) **
>
> [基于libuv的TCP设计](https://blog.csdn.net/cupidove/article/details/43056251)
>
> [服务端学习（四）libuv TCP 服务器](http://www.liuocean.com/index.php/2018/02/28/libuv-tcp-fu-wu-qi/)
>
> [libuv Introduction](https://luohaha.github.io/Chinese-uvbook/source/introduction.html)
>
> [libuv tcp socket](https://www.jianshu.com/p/1950171195cc)
>
> [uv-cpp](https://github.com/wlgq2/uv-cpp) - github
>
> [并发服务器（四）：libuv](https://linux.cn/article-9397-1.html)
>
> [libuv中文API手册，中文教程](https://blog.csdn.net/libaineu2004/article/details/78645528)
>
> [libuv多线程处理的简单示例](https://blog.csdn.net/limite_god/article/details/43668235)
>
> [C网络库使用(一):libuv的安装、多线程tcp客户端、多线程tcp服务器的使用](https://blog.csdn.net/wangdamingll/article/details/101619464)
>
> [Node.js 异步原理-线程池](https://segmentfault.com/a/1190000019111942)
>
> [I/O模型、Libuv和Eventloop](https://juejin.im/post/5cb93c726fb9a0686362dcb0)
>
> [libuv漫谈之线程](https://zhuanlan.zhihu.com/p/25973650)
>
> [libuv 多线程与队列](https://blog.csdn.net/jxyb2012/article/details/79300022)
>
> [libuv 源码分析（八）线程池（Threadpool）](https://blog.butonly.com/posts/node.js/libuv/8-libuv-threadpool/)
>
> [c++ - libuv线程安全吗？](https://mlog.club/article/170750)
>
> [libuv的线程池，即工作队列](https://blog.csdn.net/lc250123/article/details/52619314)
>
> [libuv 源码分析(4) - libuv的工作队列-线程池]([http://gngshn.github.io/2017/09/01/libuv-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-4-libuv%E7%9A%84%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97-%E7%BA%BF%E7%A8%8B%E6%B1%A0/](http://gngshn.github.io/2017/09/01/libuv-源码分析-4-libuv的工作队列-线程池/))
>
> [**Libuv学习——线程池**](https://zhuanlan.zhihu.com/p/91183396)
>
> [libuv学习笔记 - github](https://github.com/feixiao/learning-libuv/blob/master/ReadMe.md)
>
> [兄déi，libuv了解一下](https://zhuanlan.zhihu.com/p/50497450) ***
>
> [**libuv之async.c源码解析**](https://cnodejs.org/topic/5dbe64ac865a9844a301f830)
>
> [网络开源框架之libuv使用实例](https://blog.csdn.net/shixin_0125/article/details/78266291)

> [libevent基础：用libevent写服务端server程序和客户端client程序](https://blog.csdn.net/BlueCloudMatrix/article/details/43484347)
>
> [使用libevent进行多线程socket编程demo](https://www.cnblogs.com/james6176/p/4285018.html)
>
> [libevent多线程使用事项](https://www.cnblogs.com/walker-lc/articles/3601100.html)
>
> [libevent多线程](http://www.voidcn.com/article/p-goxkjymn-gt.html)
>
> [高性能、高并发TCP服务器(多线程调用libevent)](https://cloud.tencent.com/developer/article/1069895)
>
> [高性能、高并发TCP服务器(多线程调用libevent) 代码地址](https://www.open-open.com/lib/view/open1410404192289.html)
>
> []()

> [HCP服务的简介和配置详解](https://blog.51cto.com/longlei/2063336)
>
> [DHCP详解](https://blog.csdn.net/u012359618/article/details/51872678)
>
> [DHCPv6报文格式](http://www.023wg.com/message/message/cd_feature_dhcpv6_message_format.html)
>
> [DHCPV4 VS DHCPV6](https://blog.csdn.net/dragon_li_chen/article/details/7057289)
>
> [DHCP Options 43, 55, and 60 and Other Customized Options](https://docs.paloaltonetworks.com/pan-os/9-0/pan-os-admin/networking/dhcp/dhcp-options/dhcp-options-43-55-and-60-and-other-customized-options)

> [dnsmasq详解&手册](https://www.cnblogs.com/sunsky303/p/9238669.html)
>
> [dnsmasq (简体中文)]([https://wiki.archlinux.org/index.php/Dnsmasq_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)](https://wiki.archlinux.org/index.php/Dnsmasq_(简体中文)))
>
> [Dnsmasq 介绍与使用](enkichen.com/2017/05/23/dnsmasq-introduce/)



1) 增加 option 60 :

 

(a) 普通字符串

```bash
send vendor-class-identifier "name=my centos@pwd=0123456789";
```







1. BBU server（使用开源libuv封装）基本接口开发   2周
2. dnsmasq server option60解析，RRUID解析，设备类型解析，map维护， client option60内容填充 2周
3. 基于HUB，RRU环境 dhcp测试，client端调试  1-2周（RRU单片机环境调试时间不确定）
3. BBU server HUB、RRU client 启动连接，时延测量  2-3周
4. BBU server HUB、RRU client IR消息接口开发（参数get/set 告警 升级）  4周
5. BBU server 和 OAM 之间接口开发调试 2周



> [C++标准库,框架等资源大汇总！](https://www.jianshu.com/p/e4e7ed75418f)
>
> [C++ 资源大全中文版，标准库、Web应用框架、人工智能、数据库、图片处理、机器学习、日志、代码分析等](https://github.com/jobbole/awesome-cpp-cn)





```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <uv.h>

#define DEFAULT_PORT 9877 //默认端口
#define DEFAULT_BACKLOG 128 //TCP等待连接队列最大值
 
uv_loop_t *loop; //loop结构指针
struct sockaddr_in addr; //ipv4地址结构
 
typedef struct {
    uv_write_t req;
    uv_buf_t buf;
} write_req_t;

void free_write_req(uv_write_t *req) { //释放资源
    write_req_t *wr = (write_req_t*) req;
    free(wr->buf.base);
    free(wr);
}

//内存分配回调函数,buff指针用于返回相应缓冲地址！！！
void alloc_buffer(uv_handle_t *handle, size_t suggested_size, uv_buf_t *buf) { 
    buf->base = (char*) malloc(suggested_size); //堆上创建buff
    buf->len = suggested_size;
}

void echo_write(uv_write_t *req, int status) { //status返回write的结果
    if (status) {
        fprintf(stderr, "Write error %s\n", uv_strerror(status));
    }
    free_write_req(req);
}

//这些参数都是libuv库为回调函数传递的，其中nread表示当前读到的字节数,buff指向缓冲区
void echo_read(uv_stream_t *client, ssize_t nread, const uv_buf_t *buf) { 
    if (nread > 0) {
        //write_req_t这结构有点多余吧。。直接write_req_t不行么？
        write_req_t *req = (write_req_t*) malloc(sizeof(write_req_t)); 
        
        //复制缓冲区数据(从一个到另一个)
        req->buf = uv_buf_init(buf->base, nread); 
        
        //当该连接能写的时候异步调用
        //其中&req->buf指明了缓冲区的地址，1表示如果存在uv_buf_t数组，数组的元素个数
        //echo_write是uv_write_cb类型回调指针，当write完成后调用。void (*uv_write_cb)(uv_write_t* req, int status)
        uv_write((uv_write_t*) req, client, &req->buf, 1, echo_write);
                                                     
        return;
    }
    
    if (nread < 0) { //出错
        //UV_EOF不一定是0，具体见文档
        if (nread != UV_EOF)
            fprintf(stderr, "Read error %s\n", uv_err_name(nread));
        uv_close((uv_handle_t*) client, NULL);
    }
    
    free(buf->base); //释放缓冲区
}
 
//这里的status参数就是库传给我们的状态参数，指示当前connect的状态(是否能连接，是否出错等)
void on_new_connection(uv_stream_t *server, int status) {
    if (status < 0) { //<0表示出错
        fprintf(stderr, "New connection error %s\n", uv_strerror(status));
        // error!
        return;
    }

    //新建uv_tcp_t进行连接
    uv_tcp_t *client = (uv_tcp_t*) malloc(sizeof(uv_tcp_t));
    //简介之后也把这个tcp流绑定在loop上
    uv_tcp_init(loop, client);
    if (uv_accept(server, (uv_stream_t*) client) == 0) { //连接
        //连接完成后在event loop准备读取，这也是个异步回调
        //等到这个事件发生(能读)，异步回调才会开始。
        //alloc_buffer参数这里第一次碰到，其回调函数格式为void (*uv_alloc_cb)(uv_handle_t* handle, size_t suggested_size, uv_buf_t* buf)
        //该函数负责为当前行为分配缓冲区，在当前事件发生之后运行，先进行缓冲区分配工作，在这个回调函数中libuv会向你提供一个suggested_size作为缓冲区大小的建议值
        //我们需要做的是在堆上分配uv_buf_t这样的数据结构，并把buf指针指向该地址！(这个理解很关键。。。应该是这样吧？:))
        //echo_read是另一个uv_read_cb类型的回调函数，会在libuv完成read之后调用(时间点重要)。
        uv_read_start((uv_stream_t*) client, alloc_buffer, echo_read);                  
    }
    else {
        uv_close((uv_handle_t*) client, NULL); //出现错误，关闭
    }
}

int main() {
    loop = uv_default_loop(); //使用默认loop

    uv_tcp_t server; //tcp_t结构，这是在栈上分配
    uv_tcp_init(loop, &server); //算是把tcp绑定在了loop上面

    //ip和端口直接获得sockaddr_in结构。。要是自己写要好几个函数
    uv_ip4_addr("0.0.0.0", DEFAULT_PORT, &addr);
 
    //绑定tcp连接和地址
    uv_tcp_bind(&server, (const struct sockaddr*)&addr, 0);
    
    //开始监听，loop上面对于server的event监听正式开始
    //这里的几个参数才是关键：这里可以把uv_tcp_t当成uv_stream_t的子类（进行了结构体的扩展），所以这里可以使用强制类型转换绑定的流
    //on_new_connection作为一个回调函数（有固定格式，库会有参数传递），当有连接可以connect的时候进行调用，从参数来看调用时connect还没完成！
    int r = uv_listen((uv_stream_t*) &server, DEFAULT_BACKLOG, on_new_connection);
    if (r) {
        fprintf(stderr, "Listen error %s\n", uv_strerror(r)); //libuv错误处理函数
        return 1;
    }
    return uv_run(loop, UV_RUN_DEFAULT); //开始event loop
}
```





### 空转(Idling)

接下来我们通过例子来讲述监视器的使用. 例子中空转监视器回调函数被不断地重复调用, 当然其中也有一些深层次的语言，我们将会在 [*工具集*](http://forhappy.github.com/uvbook/utilities.html) 进一步讨论, 但现在我们只是跳过具体细节. 我们只是使用了一个空转监视器回调来看看监视器的生命周期, 通过例子我们也可以了解到： 由于设置了监视器, 所以调用 `uv_run()` 是程序会阻塞, 空转监视器将会在计数器达到设定的值时停止(监视), `uv_run()` 会退出因为此时程序中没有活动的监视器了.

```c++
#include <stdio.h>
#include <uv.h>

int64_t counter = 0;

void wait_for_a_while(uv_idle_t* handle, int status) {
    counter++;

    if (counter >= 10e6)
        uv_idle_stop(handle);
}

int main() {
    uv_idle_t idler;
    uv_idle_init(uv_default_loop(), &idler);
    uv_idle_start(&idler, wait_for_a_while);

    printf("Idling...\n");
    uv_run(uv_default_loop(), UV_RUN_DEFAULT);

    return 0;
}
```







> [基于libuv的TCP设计（三）](https://www.cnblogs.com/wqvbjhc/p/4175469.html)

